/*
ï¿½ Namawell 
 * RFID demo project

 * This file contains all the functions that are not generated by the MCC
*/
#include "stm32g0xx_it.h"
#include "functions.h"

//---------------------------------------------------------------------------------------
    uint8_t sensorData[16];
    uint8_t dummyBuffer[16];  // To send dummy bytes for reading
    
// Redirected the systick function here.
// So that there is a minimum change to the auto-generated stm32g0xx.it.c file.
void HAL_IncTick(void)
    {
      uwTick += (uint32_t)uwTickFreq;
      pgv->timerFlags |= ftimer_01ms;
// For delay
      if (pgv->delayTimeCounter > 0)      //The delay function must be inside the ISR
      {
          pgv->delayTimeCounter--;
      }
    }

void shortDelay(uint16_t time)     // delay a number of Fosc cycles. Not accurate
{
    while (time > 0)
    {
        time--;
    }
}

void timedAppTasks(void)
{

    if (pgv->timerFlags & ftimer_01ms)
    {
        timedEvents_01ms();
    }
    
    if (pgv->timerFlags & ftimer_05ms)
    {
        timedEvents_05ms();
    }
    if (pgv->timerFlags & ftimer_10ms)
    {
        timedEvents_10ms();     //To read sensor data and send them to UART2
    }
    
    if (pgv->timerFlags & ftimer_50ms)
    {
        timedEvents_50ms();     //To read sensor data and send them to UART2
    }    
    
    if (pgv->timerFlags & ftimer_100ms)
    {
        timedEvents_100ms();     //To read tag data and send them to UART2
    }

    if (pgv->UART2Flags & fUART2_RxMsgReady)
    {
        
        UART2_RxMessageProcess();
    }
}


void timedEvents_01ms(void)
{
    pgv->timerFlags &= ~ftimer_01ms;

    //--- Timed events
    pgv->timerCnt_05ms++;
    if (pgv->timerCnt_05ms == 5)
    {
        pgv->timerCnt_05ms = 0;
        pgv->timerFlags |= ftimer_05ms;
    }
    
    pgv->timerCnt_10ms++;
    if (pgv->timerCnt_10ms == 10)
    {
        pgv->timerCnt_10ms = 0;
        pgv->timerFlags |= ftimer_10ms;
    }
    
    pgv->timerCnt_50ms++;
    if (pgv->timerCnt_50ms == 50)
    {
        pgv->timerCnt_50ms = 0;
        pgv->timerFlags |= ftimer_50ms;
    }
    
    pgv->timerCnt_100ms++;
    if (pgv->timerCnt_100ms == 100)
    {
        pgv->timerCnt_100ms = 0;
        pgv->timerFlags |= ftimer_100ms;
    }  

}

void timedEvents_05ms(void)
{
    pgv->timerFlags &= ~ftimer_05ms;
    // LATDbits.LATD10 ^= 1;
} 

void timedEvents_10ms(void)
{
    pgv->timerFlags &= ~ftimer_10ms;

}

void timedEvents_50ms(void)
{

    pgv->timerFlags &= ~ftimer_50ms;


}

void timedEvents_100ms(void)
{
	static uint8_t tcnt = 0;

    pgv->timerFlags &= ~ftimer_100ms;

    if (tcnt++ > 4)
    {
    	tcnt = 0;
    	HAL_GPIO_TogglePin(USERLED_GPIO_Port, USERLED_Pin);
    }

	pgv->sensorFlags ^= factiveSensor;

	if (pgv->sensorFlags & factiveSensor)	//Get the mag senosr data
	{
		if(pgv->mSensorFlags & fmsensor_ready)
		{
			if (mSensor_Read() == HAL_OK)	//To read the x, y, z magnetic fields

			{
				pgv->txBuffer[1] = MAG_SENSOR_DATA_ID;

				pgv->txBuffer[0] = MSG_HEADER_OUT;

				pgv->txBuffer[2] = pgv->magnetData[0];
				pgv->txBuffer[3] = pgv->magnetData[1];
				pgv->txBuffer[4] = pgv->magnetData[2];
				pgv->txBuffer[5] = pgv->magnetData[3];
				pgv->txBuffer[6] = pgv->magnetData[4];
				pgv->txBuffer[7] = pgv->magnetData[5];

				HAL_UART_Transmit_IT(&huart2, pgv->txBuffer, 8);
			}
		} else
		{
			mSensor_Init();	//Repeat trying
		}
	} else		//Get the ACC sensor data
	{
		if(pgv->gSensorFlags & fgsensor_ready)
		{
			if (gSensor_Read() == HAL_OK)	//To read the x, y, z magnetic fields

			{
				pgv->txBuffer[1] = ACC_SENSOR_DATA_ID;

				pgv->txBuffer[0] = MSG_HEADER_OUT;

				pgv->txBuffer[2] = pgv->gData[0];
				pgv->txBuffer[3] = pgv->gData[1];
				pgv->txBuffer[4] = pgv->gData[2];
				pgv->txBuffer[5] = pgv->gData[3];
				pgv->txBuffer[6] = pgv->gData[4];
				pgv->txBuffer[7] = pgv->gData[5];

				HAL_UART_Transmit_IT(&huart2, pgv->txBuffer, 8);

			}
		} else
		{
			gSensor_Init();	//Repeat trying
		}
	}
}


void myDelay(uint16_t delayTime)    // delay Time in ms. using timer1
{
    pgv->delayTimeCounter = delayTime;
    while (pgv->delayTimeCounter);   //delay time is counted in the TimeoutCallback 
}


void HAL_UART_TxCpltCallback(UART_HandleTypeDef *husart)
{
    // Transmission complete, handle the event here
    // Example: Toggle an LED or send a message
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{ 


	pgv->rxBufferIndex++;
    if (pgv->rxBufferIndex >= pgv->bytesToRx)
    {
    	pgv->rxBufferIndex = 0;
        pgv->UART2Flags |= fUART2_RxMsgReady;
    }
	HAL_UART_Receive_IT(&huart2, &pgv->rxBuffer[pgv->rxBufferIndex], 1);
} 

void UART2_RxMessageProcess(void)
{
    pgv->UART2Flags &= ~fUART2_RxMsgReady;

    if ((pgv->rxBuffer[0] == 0x55) && (pgv->rxBuffer[1] == 0xAA))
    {
    	pgv->txBuffer[0] = MSG_HEADER_OUT;
    	pgv->txBuffer[1] = 0x01;			// message received
        pgv->txBuffer[2] = 'O';
        pgv->txBuffer[3] = 'K';

        HAL_UART_Transmit_IT(&huart2, pgv->txBuffer, 8);
    }
}

void App_Init(void)	// To initialize some parameters and initiate uart receiving
{
	for (uint8_t i = 0; i<6; i++)
	{
		pgv->magnetData[i] = 0x31+i;
		pgv->gData[i] = 0x31+i;
	}

// initiate UART receiving
	pgv->rxBufferIndex = 0;
	pgv->bytesToRx = 2; 	//To receive 2 bytes
	HAL_UART_Receive_IT(&huart2, &pgv->rxBuffer[pgv->rxBufferIndex], 1);

// initialize the magnetic sensor
	HAL_GPIO_WritePin(SENSOR_PWR_GPIO_Port, SENSOR_PWR_Pin, GPIO_PIN_RESET);
	myDelay(100);		//Delay 100ms;
	HAL_GPIO_WritePin(SENSOR_PWR_GPIO_Port, SENSOR_PWR_Pin, GPIO_PIN_SET);
	myDelay(100);		//Delay 100ms;

	mSensor_Init();
	gSensor_Init();


}

HAL_StatusTypeDef mSensor_Init(void)
{
	myDelay(10);		//Delay 10ms;

	if (mSensor_Read_Register(0x0F) == HAL_OK)
	{
		if (pgv->i2cRxBuffer[0] == MAG_SENSOR_ID)
		{
			mSensor_Write_Register(0x20, 0x30);  // Set ODR to 10Hz, enable X, Y, Z, medium performance
			mSensor_Write_Register(0x21, GAUSS_SCALE_16);  // gauss scale
			mSensor_Write_Register(0x22, 0x00);  // Continuous-conversion mode
			mSensor_Write_Register(0x23, 0x0C);  // High-performance mode for Z-axis

			pgv->mSensorFlags |= fmsensor_ready;
			return HAL_OK;
		} else
		{
			pgv->mSensorFlags &= ~fmsensor_ready;
			return HAL_ERROR;		// Failed with identification
		}
	} else
	{
		return HAL_ERROR;		// Failed communicates with the sensor
	}

}

HAL_StatusTypeDef mSensor_Read(void)	// To read the magnetic fields out, x, y, z total 6 bytes.
{
	uint8_t result, i;
	// 6 bytes starting from 0x28, continuous read

	if (mSensor_Read_Block(0x28, pgv->i2cRxBuffer, 6) == HAL_OK)
	{
    	for (i=0; i<6; i++)
    	{
    		pgv->magnetData[i] = pgv->i2cRxBuffer[i];
    	}
		result = HAL_OK;
	} else
	{
		result = HAL_ERROR;
	}
	return result;
}

HAL_StatusTypeDef mSensor_Read_Register(uint8_t regAddr)	//Return the register value
{
	// read one register value

    // Send the register address to the sensor
    if (HAL_I2C_Master_Transmit(&hi2c1, I2C_ADD_MAG_WR, &regAddr, 1, HAL_MAX_DELAY) != HAL_OK)
    {
        return HAL_ERROR;
    }

    // Receive the data from the sensor
    return HAL_I2C_Master_Receive(&hi2c1, I2C_ADD_MAG_RD, pgv->i2cRxBuffer, 1, HAL_MAX_DELAY);

}


HAL_StatusTypeDef mSensor_Read_Block(uint8_t regAddr, uint8_t *pdata, uint8_t length)	//To read a block of data out of the sensor
{
    regAddr |= 0x80;  			// Starting register address with auto-increment

    // Send the register address (with auto-increment bit)
    if (HAL_I2C_Master_Transmit(&hi2c1, I2C_ADD_MAG_WR, &regAddr, 1, HAL_MAX_DELAY) != HAL_OK)
    {
        return HAL_ERROR;
    }

    // Receive the bytes
    if (HAL_I2C_Master_Receive(&hi2c1, I2C_ADD_MAG_RD, pdata, length, HAL_MAX_DELAY) != HAL_OK)
    {
        return HAL_ERROR;
    }

    return HAL_OK;
}

HAL_StatusTypeDef mSensor_Write_Register(uint8_t regAddr, uint8_t data)		// To write one byte to the register
{
	uint8_t txData[2];  // Transmit buffer: register address + data
	txData[0] = regAddr;  // Register address
	txData[1] = data;     // Data to be written

    // Send the register address and data
    return HAL_I2C_Master_Transmit(&hi2c1, I2C_ADD_MAG_WR, txData, 2, HAL_MAX_DELAY);

}

//-----------------
HAL_StatusTypeDef gSensor_Init(void)
{
	myDelay(10);		//Delay 10ms;

	if (gSensor_Read_Register(0x00) == HAL_OK)		//Chip ID register
	{
		if (pgv->i2cRxBuffer[0] == 0x90)
		{
			pgv->gSensorFlags |= fgsensor_ready;
			//Configure the sensor
			gSensor_Write_Register(0x19, 0x02);  // To enter normal mode, set register ACC_Config0 (0x19 to 0x02)
			gSensor_Write_Register(0x1A, 0x38);  // range=2g, osr=3, acc_odr=100Hz, ACC_CONFIG1
			gSensor_Write_Register(0x1B, 0x04);  // Use acc_filt2(100Hz) as data source, ACC_CONFIG2

			return HAL_OK;
		} else
		{
			pgv->gSensorFlags &= ~fgsensor_ready;
			return HAL_ERROR;		// Failed with identification
		}
	} else
	{
		return HAL_ERROR;		// Failed communicates with the sensor
	}
}

HAL_StatusTypeDef gSensor_Read(void)	// To read the magnetic fields out, x, y, z total 6 bytes.
{
	uint8_t result, i;
	// 6 bytes starting from 0x04, continuous read

	if (gSensor_Read_Block(0x04, pgv->i2cRxBuffer, 6) == HAL_OK)
	{
    	for (i=0; i<6; i++)
    	{
    		pgv->gData[i] = pgv->i2cRxBuffer[i];
    	}
		result = HAL_OK;
	} else
	{
		result = HAL_ERROR;
	}
	return result;
}

HAL_StatusTypeDef gSensor_Read_Register(uint8_t regAddr)	//Return the register value
{
	// read one register value

    // Send the register address to the sensor
    if (HAL_I2C_Master_Transmit(&hi2c1, I2C_ADD_ACC_WR, &regAddr, 1, HAL_MAX_DELAY) != HAL_OK)
    {
        return HAL_ERROR;
    }

    // Receive the data from the sensor
    return HAL_I2C_Master_Receive(&hi2c1, I2C_ADD_ACC_RD, pgv->i2cRxBuffer, 1, HAL_MAX_DELAY);

}


HAL_StatusTypeDef gSensor_Read_Block(uint8_t regAddr, uint8_t *pdata, uint8_t length)	//To read a block of data out of the sensor
{
    //regAddr |= 0x80;  			// Starting register address with auto-increment, not needed for g sensor

    // Send the register address (with auto-increment bit)
    if (HAL_I2C_Master_Transmit(&hi2c1, I2C_ADD_ACC_WR, &regAddr, 1, HAL_MAX_DELAY) != HAL_OK)
    {
        return HAL_ERROR;
    }

    // Receive the bytes
    if (HAL_I2C_Master_Receive(&hi2c1, I2C_ADD_ACC_RD, pdata, length, HAL_MAX_DELAY) != HAL_OK)
    {
        return HAL_ERROR;
    }

    return HAL_OK;
}

HAL_StatusTypeDef gSensor_Write_Register(uint8_t regAddr, uint8_t data)		// To write one byte to the register
{
	uint8_t txData[2];  // Transmit buffer: register address + data
	txData[0] = regAddr;  // Register address
	txData[1] = data;     // Data to be written

    // Send the register address and data
    return HAL_I2C_Master_Transmit(&hi2c1, I2C_ADD_ACC_WR, txData, 2, HAL_MAX_DELAY);

}

//-----------------------
